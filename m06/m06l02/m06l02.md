# Занятие 2: API. Создание API с помощью Flask

## 1. Обзор Flask

### Что такое Flask?

**Flask** — это микрофреймворк для разработки веб-приложений на языке Python. Это **легковесный и гибкий** инструмент, который позволяет разработчикам быстро создавать веб-приложения и API, не перегружая их излишними настройками и конфигурациями. Flask предоставляет разработчикам минимальный набор функций, оставляя большую свободу выбора для добавления дополнительных библиотек и функционала. 

**Особенности Flask:**
- **Микрофреймворк:** Это значит, что Flask предоставляет только основные инструменты для создания веб-приложений (например, маршрутизация и обработка запросов), но не навязывает дополнительные компоненты, такие как системы аутентификации, формы или ORM. Все это можно подключать по мере необходимости.
- **Легковесность:** Flask не включает в себя много лишних компонентов, поэтому его можно настроить под любые нужды проекта. Он идеально подходит для небольших и средних проектов.
- **Гибкость:** Вы можете выбирать, какие библиотеки использовать и как структурировать проект. Flask позволяет интегрировать различные базы данных, системы аутентификации и другие сторонние инструменты.

**Flask** основан на WSGI (Web Server Gateway Interface), что позволяет интегрировать его с различными веб-серверами (например, Nginx, Apache) и запускать в продакшн-среде. Также он использует **Jinja2** для шаблонов и **Werkzeug** для работы с HTTP-запросами.

### Основные особенности Flask

1. **Легкость в использовании**  
   Flask минималистичен, но при этом очень мощный. Его API легко понимать, а разработка приложений на его основе не требует огромных усилий. В отличие от более тяжелых фреймворков, таких как Django, Flask не навязывает строгую структуру проекта и предоставляет только основные функции. Это облегчает начало разработки и позволяет быстро создать прототипы.

2. **Маршрутизация**  
   Flask использует декораторы для маршрутизации URL-запросов. Каждый маршрут (URL) связан с функцией, которая обрабатывает соответствующие запросы (GET, POST, и т.д.). Например, можно связать маршрут `/hello` с функцией, которая возвращает текст "Hello, World!".

3. **Шаблоны (Jinja2)**  
   Flask использует систему шаблонов Jinja2 для генерации HTML-страниц. Это позволяет разработчикам отделить логику обработки данных от визуального представления. Вы можете использовать переменные и управляющие конструкции прямо в шаблонах, что делает динамическое создание веб-страниц удобным и эффективным.

4. **Поддержка REST API**  
   Flask идеально подходит для создания RESTful API. Благодаря своей легковесности и гибкости, он позволяет легко обрабатывать различные HTTP-методы (GET, POST, PUT, DELETE) и возвращать данные в формате JSON, что делает его популярным выбором для создания API.

5. **Встроенные инструменты разработки**  
   Flask поставляется с несколькими встроенными инструментами для разработки, такими как встроенный сервер для тестирования и отладки, возможность автоматической перезагрузки при изменении кода и другие полезные функции для ускорения процесса разработки.

6. **Расширяемость**  
   Flask предоставляет множество расширений, которые можно подключить для добавления функционала, такого как аутентификация, ORM (Object-Relational Mapping), формы, проверка данных и другие. Это позволяет легко кастомизировать приложение под ваши нужды.

### Установка Flask (через pip)

Для начала работы с Flask нужно установить его на вашу машину. Это можно сделать с помощью пакета **pip** — стандартного менеджера пакетов Python.

**Установка Flask:**

   Установить Flask через pip. Введите следующую команду:

   - Для установки Flask:
     ```bash
     pip install Flask
     ```

   Это установит последнюю стабильную версию Flask в ваше виртуальное окружение. 

**Проверка установки:**

   Чтобы убедиться, что Flask установлен правильно, выполните команду:

   ```bash
   python -m flask --version
   ```

   Это выведет версию установленного Flask. Если установка прошла успешно, вы увидите что-то вроде:
   ```
   Flask 2.2.2
   ```

## 2. Создание простого нового проекта Flask

При создании нового проекта на Flask важно правильно настроить структуру каталогов и правильно организовать файл приложения. В этом разделе мы рассмотрим, как создать базовый проект Flask и как организовать его структуру для удобства разработки.

### Создание и настройка нового проекта

Когда вы начинаете работать с Flask, основная задача — настроить проект так, чтобы его было легко поддерживать и развивать. Правильная структура каталогов — это важная часть, которая поможет вам организовать файлы и ресурсы, а также работать с проектом более эффективно.

#### 1. Создание каталога проекта

Первым шагом будет создание каталога для вашего проекта. Обычно проект называют по имени или описанию его задачи.

1. Откройте терминал (или командную строку).
2. Перейдите в директорию, где хотите создать новый проект.
3. Создайте новый каталог для проекта:

   ```bash
   mkdir flask_project
   cd flask_project
   ```

   Этот каталог будет содержать все файлы и папки, связанные с вашим приложением Flask.

#### 2. Создание виртуального окружения

Очень важно работать в изолированном окружении, чтобы зависимости вашего проекта не конфликтовали с глобальными пакетами Python.

1. Для создания виртуального окружения выполните команду:

   - Для Windows:
     ```bash
     python -m venv venv
     ```

   - Для macOS/Linux:
     ```bash
     python3 -m venv venv
     ```

2. После этого активируйте виртуальное окружение:

   - Для Windows:
     ```bash
     .\venv\Scripts\activate
     ```

   - Для macOS/Linux:
     ```bash
     source venv/bin/activate
     ```

   В командной строке теперь будет отображаться префикс `(venv)`, что указывает на то, что виртуальное окружение активно.

#### 3. Установка Flask

Теперь, когда виртуальное окружение создано и активировано, установим Flask:

```bash
pip install Flask
```

Это установит последнюю версию Flask в ваше виртуальное окружение.

#### 4. Структура каталогов

Когда проект Flask начинает расти, его необходимо структурировать для удобства работы. Вот пример базовой структуры каталогов для небольшого проекта Flask:

```
flask_project/
│
├── venv/                # Виртуальное окружение
├── app/                 # Основная папка приложения
│   ├── __init__.py      # Инициализация пакета Flask
│   ├── routes.py        # Маршруты приложения
│   └── templates/       # Шаблоны HTML
│   └── static/          # Статические файлы (CSS, JS, изображения)
│
├── config.py            # Конфигурационные файлы
├── requirements.txt     # Список зависимостей
└── run.py               # Скрипт для запуска приложения
```

#### 5. Пояснение структуры каталогов

- **venv/** — каталог для виртуального окружения. Здесь хранятся все установленные пакеты, включая Flask.
- **app/** — основная папка, которая содержит логику приложения.
  - **`__init__.py`** — файл, который инициализирует пакет Flask. Обычно здесь создаётся объект приложения и загружаются конфигурации.
  - **routes.py** — файл для определения маршрутов, в котором связываются URL-адреса с функциями обработчиками.
  - **templates/** — папка для хранения шаблонов HTML. Flask использует систему шаблонов Jinja2 для динамической генерации HTML.
  - **static/** — папка для хранения статических файлов, таких как изображения, стили (CSS) и JavaScript.
- **config.py** — файл для конфигурации приложения, например, настройки базы данных, секретных ключей и т.д.
- **requirements.txt** — текстовый файл, в котором перечислены все зависимости проекта. Этот файл позволяет легко установить все нужные пакеты через команду `pip install -r requirements.txt`.
- **run.py** — основной скрипт для запуска приложения Flask. В нем запускается сервер для локальной разработки.

### Основной файл приложения

Основной файл приложения — это файл, который будет запускать Flask-приложение и содержать основную логику.

1. **Создайте файл `run.py`:**

   В корне вашего проекта создайте файл `run.py`. В нем будет происходить запуск приложения. Пример содержимого файла `run.py`:

   ```python
   from app import create_app

   app = create_app()

   if __name__ == '__main__':
       app.run(debug=True)
   ```

   В этом файле:
   - Мы импортируем функцию `create_app` из пакета `app`. Эта функция будет отвечать за настройку и создание объекта Flask.
   - Создаем объект приложения `app` с помощью вызова `create_app()`.
   - Запускаем приложение, если файл запускается напрямую (`if __name__ == '__main__'`).

2. **Создание `app/__init__.py`:**

   В папке `app/` создайте файл `__init__.py`. Этот файл будет содержать функцию `create_app`, которая будет инициализировать ваше Flask-приложение и конфигурацию.

   Пример содержимого файла `app/__init__.py`:

   ```python
   from flask import Flask

   def create_app():
       app = Flask(__name__)

       # Здесь можно добавить настройки конфигурации
       # app.config.from_object('config.Config')

       # Импортировать маршруты
       from . import routes
       app.register_blueprint(routes.bp)

       return app
   ```

   В этой функции:
   - Создается объект Flask с помощью `Flask(__name__)`.
   - Загружаются конфигурации из файла `config.py` (обратите внимание на строку `app.config.from_object('config.Config')`).
   - Импортируются маршруты из файла `routes.py`, и добавляются в приложение через `app.register_blueprint()`. Использование Blueprints позволяет разделить приложение на несколько модулей.

3. **Создание `app/routes.py`:**

   В файле `routes.py` мы будем описывать маршруты для нашего приложения. Пример содержимого файла `app/routes.py`:

   ```python
   from flask import Blueprint, render_template

   bp = Blueprint('main', __name__)

   @bp.route('/')
   def home():
       return render_template('index.html')
   ```

   В этом файле:
   - Мы создаем `Blueprint` с именем `main`. Blueprint позволяет структурировать маршруты и обработчики.
   - Создаем маршрут `/`, который будет обрабатывать GET-запросы и возвращать HTML-страницу с помощью функции `render_template`.

4. **Создание шаблонов и статических файлов:**

   - В папке `app/templates/` создайте файл `index.html`, который будет отображаться при обращении к маршруту `/`:
   
     ```html
     <!DOCTYPE html>
     <html lang="en">
     <head>
         <meta charset="UTF-8">
         <meta name="viewport" content="width=device-width, initial-scale=1.0">
         <title>Flask App</title>
     </head>
     <body>
         <h1>Welcome to the Flask Application!</h1>
     </body>
     </html>
     ```

   - В папке `app/static/` можно хранить CSS, изображения и JavaScript. Например, создайте файл `style.css` в папке `static/` для стилизации страницы.

### Запуск проекта

Теперь, когда структура проекта настроена, можно запустить приложение. В терминале введите команду:

```bash
python run.py
```

Это запустит локальный сервер Flask, и вы сможете открыть браузер по адресу `http://127.0.0.1:5000/` и увидеть страницу с текстом "Welcome to the Flask Application!".

## 3. Обработка HTTP-запросов в Flask

Одной из ключевых задач при разработке веб-приложений является **обработка HTTP-запросов**. Flask предоставляет мощные средства для работы с различными типами запросов, такими как **GET**, **POST** и другими. Также важно правильно обрабатывать параметры, передаваемые в запросах, и уметь управлять ошибками, возникающими в процессе работы с запросами.

### 1. Обработка GET-запросов

**GET-запросы** — это запросы, которые отправляются на сервер для получения данных. Этот запрос часто используется для отображения информации пользователю, например, для загрузки веб-страниц.

#### Пример обработки GET-запроса:

```python
from flask import Flask

app = Flask(__name__)

@app.route('/')
def home():
    return 'Hello, World!'

if __name__ == '__main__':
    app.run(debug=True)
```

- **`@app.route('/')`** — этот декоратор связывает URL-путь (в данном случае, корневой URL `/`) с функцией `home()`. При запросе GET на адрес `/`, функция `home()` будет вызвана и вернёт строку "Hello, World!".
  
- **`app.run(debug=True)`** — запускает сервер Flask в режиме отладки, что полезно для отслеживания ошибок и автоматической перезагрузки приложения при изменении кода.

#### Основные моменты при обработке GET-запросов:

- **GET-запросы** обычно не изменяют состояние сервера, они лишь запрашивают данные.
- Результат обработки GET-запроса может быть **HTML**, **JSON**, **XML** или даже простой текст, в зависимости от настроек.
- Использование метода `@app.route()` позволяет указать, какой URL должен быть связан с какой функцией.

#### Пример с динамическими данными:

Допустим, вам нужно вернуть страницу, которая приветствует пользователя по имени, которое передается в URL.

```python
@app.route('/hello/<name>')
def hello(name):
    return f'Hello, {name}!'
```

Здесь **`<name>`** — это динамическая часть URL. Если пользователь заходит по URL `/hello/John`, функция `hello()` будет вызвана, и пользователю будет возвращено сообщение `Hello, John!`.

### 2. Обработка POST-запросов

**POST-запросы** обычно используются для отправки данных на сервер. Например, они могут быть использованы для отправки формы, загрузки файлов или отправки данных через AJAX.

#### Пример обработки POST-запроса:

```python
from flask import Flask, request

app = Flask(__name__)

@app.route('/submit', methods=['POST'])
def submit():
    data = request.form['name']
    return f'Hello, {data}!'

if __name__ == '__main__':
    app.run(debug=True)
```

- **`methods=['POST']`** — указывает, что этот маршрут будет обрабатывать только **POST**-запросы. В случае запроса типа GET данный маршрут не будет срабатывать.
- **`request.form['name']`** — доступ к данным формы. `request.form` — это объект, который содержит все данные, отправленные через форму методом POST. Мы получаем значение поля с именем `name`.

#### Пример с HTML-формой для отправки POST-запроса:

```html
<form action="/submit" method="POST">
    <input type="text" name="name" placeholder="Enter your name">
    <button type="submit">Submit</button>
</form>
```

Когда пользователь заполняет форму и нажимает на кнопку "Submit", данные формы отправляются методом POST на сервер, и Flask вызывает функцию `submit()`, возвращая сообщение с введенным именем.

#### Важные моменты при работе с POST-запросами:

- Для обработки POST-запросов необходимо указать параметр **`methods=['POST']`** в декораторе маршрута.
- Данные из формы можно получить через **`request.form`**, который является словарем всех отправленных полей.
- Для работы с файлами в POST-запросах используйте **`request.files`**.

### 3. Работа с параметрами URL

В Flask можно получать параметры, передаваемые в URL. Параметры URL могут быть частью пути или переданы как **query parameters** (строка запроса).

#### Пример с query parameters:

Query parameters — это параметры, которые передаются в URL после знака вопроса `?`. Например, в URL `http://example.com/search?q=flask&page=2` параметры `q` и `page` передаются как часть строки запроса.

```python
@app.route('/search')
def search():
    query = request.args.get('q')
    page = request.args.get('page', 1)  # Если параметр 'page' не передан, по умолчанию будет 1
    return f'Search query: {query}, Page: {page}'
```

Здесь:
- **`request.args.get('q')`** — получает значение параметра `q` из строки запроса.
- **`request.args.get('page', 1)`** — получает значение параметра `page`. Если он отсутствует, возвращается значение по умолчанию (в данном случае — 1).

#### Пример URL с параметрами:

```text
/search?q=flask&page=2
```

Результатом будет строка:

```text
Search query: flask, Page: 2
```

#### Важные моменты при работе с параметрами URL:

- **Параметры пути** (например, `<username>`) передаются в URL как часть пути, и их можно использовать для динамического создания контента.
- **Query параметры** передаются в URL после знака `?` и могут быть получены через `request.args`.
- Если параметр отсутствует, можно задать значение по умолчанию с помощью второго аргумента метода `get()`.

### 4. Обработка ошибок (404, 405 и т.д.)

Flask предоставляет несколько встроенных механизмов для обработки ошибок. Основные ошибки, с которыми вам возможно придется столкнуться:
- **404** — страница не найдена.
- **405** — метод не разрешен.
- **500** — внутренняя ошибка сервера.

#### Обработка ошибки 404 (страница не найдена):

Flask автоматически генерирует ошибку 404, если пользователь запрашивает несуществующий маршрут. Однако можно переопределить обработку ошибок и вернуть кастомное сообщение или страницу.

```python
@app.errorhandler(404)
def page_not_found(e):
    return 'Sorry, this page does not exist', 404
```

В этом примере мы создали обработчик для ошибки 404, который будет возвращать текстовое сообщение, если страница не найдена.

#### Обработка ошибки 405 (метод не разрешен):

Ошибка 405 возникает, если пользователь отправляет запрос методом, который не поддерживается для данного маршрута (например, POST вместо GET).

```python
@app.errorhandler(405)
def method_not_allowed(e):
    return 'Method not allowed', 405
```

#### Общий обработчик ошибок:

Если вы хотите обрабатывать все возможные ошибки централизованно, вы можете использовать общий обработчик для всех ошибок:

```python
@app.errorhandler(Exception)
def handle_exception(e):
    return f'An error occurred: {str(e)}', 500
```

#### Важные моменты при обработке ошибок:

- Вы можете использовать декоратор `@app.errorhandler` для перехвата и обработки различных типов ошибок.
- Для ошибок можно возвращать как текст, так и целые HTML-страницы, в зависимости от требований.
- Важно предоставлять пользователям понятные и информативные страницы ошибок, чтобы они могли правильно реагировать на возникающие проблемы.

## 4. Создание и возвращение JSON-ответов

**JSON (JavaScript Object Notation)** — это популярный текстовый формат для обмена данными, который часто используется в веб-разработке и при создании API. В Flask создание и отправка JSON-ответов является важной частью взаимодействия клиента с сервером, особенно когда речь идет о **RESTful API**.

### 1. Важность формата JSON для API

**JSON** стал стандартом для передачи данных между сервером и клиентом благодаря своей легкости, читаемости и совместимости с большинством языков программирования. Это особенно важно для **веб-приложений**, где клиент (например, браузер или мобильное приложение) может взаимодействовать с сервером с помощью API, часто используя формат JSON для получения и отправки данных.

#### Почему JSON так важен?

- **Читаемость**: JSON легко читается как людьми, так и машинами. Это простой текстовый формат, который легко парсится в любом языке программирования.
- **Легкость**: JSON имеет минимальную структуру, которая легко сериализуется (преобразуется) и десериализуется (переводится обратно в объект).
- **Гибкость**: JSON поддерживает вложенные структуры данных, включая массивы и объекты, что позволяет передавать сложные данные.
- **Совместимость**: JSON поддерживается большинством языков программирования и инструментов, таких как JavaScript, Python, Ruby, Java, PHP и многие другие.

Веб-сервисы, использующие **REST** (Representational State Transfer), предпочитают JSON как основной формат для обмена данными. Например, в Flask API часто используется JSON для передачи информации между клиентом и сервером.

### 2. Использование библиотеки `jsonify` для сериализации данных

В Flask для работы с JSON-данными используется встроенная функция **`jsonify`**. Она позволяет удобно преобразовать Python-объекты (например, словари или списки) в корректный JSON-формат.

#### Что делает `jsonify`?

- **Сериализация**: Преобразует Python-данные в JSON-формат.
- **Заголовки**: Устанавливает правильные заголовки HTTP, указывая, что ответ является **JSON** (например, `Content-Type: application/json`).
- **Гибкость**: Поддерживает все типы данных, которые можно сериализовать в JSON, включая строки, числа, списки, словари.

#### Пример использования `jsonify`:

```python
from flask import Flask, jsonify

app = Flask(__name__)

@app.route('/api/data')
def get_data():
    data = {
        'name': 'Flask API',
        'version': '1.0',
        'features': ['lightweight', 'easy to use', 'flexible']
    }
    return jsonify(data)

if __name__ == '__main__':
    app.run(debug=True)
```

В этом примере:
- Функция `get_data()` создаёт Python-словарь с некоторыми данными.
- Затем мы используем **`jsonify(data)`**, чтобы сериализовать словарь в формат JSON и вернуть его как ответ на запрос.
- Flask автоматически устанавливает заголовок `Content-Type: application/json`, указывая, что ответ в формате JSON.

#### Примечания:
- В **JSON** все ключи в объекте (словаре) должны быть строками, и `jsonify` автоматически приводит их к строковому типу.
- Если необходимо вернуть данные с вложенной структурой (например, массивы или другие словари), `jsonify` справится с этим без дополнительных усилий.

### 3. Структура ответа API (HTTP-статус, тело ответа)

При создании API важно правильно формировать **структуру ответа**. Стандартный ответ HTTP включает в себя как **тело ответа** (данные), так и **статусный код**.

#### 1. HTTP-статус

HTTP-статусный код сообщает клиенту о результате обработки запроса сервером. Статус код состоит из трех цифр:
- Первая цифра указывает на категорию ошибки или успеха.
- Остальные две цифры — это более конкретное описание результата.

Основные категории статусных кодов:
- **2xx** — Успешные запросы (например, 200 OK).
- **4xx** — Ошибки клиента (например, 404 Not Found).
- **5xx** — Ошибки сервера (например, 500 Internal Server Error).

Для успешных запросов часто используется статусный код **200 OK**.

#### 2. Тело ответа

**Тело ответа** — это фактические данные, которые сервер отправляет клиенту. В случае API, это чаще всего **JSON-данные**. Ответ может содержать как основные данные, так и дополнительные метаданные (например, количество элементов в списке, статус операции и т.д.).

#### Пример с указанием HTTP-статуса и тела ответа:

```python
from flask import Flask, jsonify

app = Flask(__name__)

@app.route('/api/data', methods=['GET'])
def get_data():
    data = {
        'name': 'Flask API',
        'version': '1.0',
        'features': ['lightweight', 'easy to use', 'flexible']
    }
    return jsonify(data), 200  # Статус 200 OK

if __name__ == '__main__':
    app.run(debug=True)
```

В этом примере:
- Мы возвращаем JSON-ответ с данными о приложении.
- **`200`** — это код статуса, который сообщает клиенту, что запрос был успешно обработан.

#### Пример с ошибкой 404:

Если клиент запрашивает несуществующий ресурс, можно вернуть ошибку 404 с дополнительным сообщением в теле ответа:

```python
@app.route('/api/unknown')
def unknown_resource():
    return jsonify({'error': 'Resource not found'}), 404
```

В этом случае:
- Мы возвращаем код ошибки **404** с сообщением, поясняющим, что ресурс не найден.
- Ответ в формате JSON поможет клиенту легко распарсить ошибку и обработать её.
